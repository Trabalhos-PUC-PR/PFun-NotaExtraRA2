module Ex1 where
import Text.Read
import Data.Maybe (isJust)
-- Exerc√≠cio 1:  CALCULADORA

-- Voc√™ dever√° implementar, em Haskell, uma calculadora capaz de realizar, em n√∫meros reais, as quatro opera√ß√µes, as opera√ß√µes trigonom√©tricas (seno, cosseno e tangente) e as opera√ß√µes de exponencia√ß√£o (quadrado, cubo, raiz quadrada, raiz c√∫bica e x elevado a y). Usando nota√ß√£o rpn de tal forma que todas as opera√ß√µes sejam representadas por uma S-expression. Como mostrado no exemplo
-- a seguir:
-- ùëé) ( 3.4 5.0 +)
-- ùëè) ( 3.4 (3.0 2 ùê∏ùëãùëÉ) +)
-- Caber√° a voc√™ definir como ir√° separar os operandos de cada opera√ß√£o. Tamb√©m caber√° a voc√™ determinar as palavras chaves que usar√° para representar as opera√ß√µes trigonom√©tricas (seno, cosseno e tangente) e as opera√ß√µes de exponencia√ß√£o (quadrado, cubo, raiz quadrada, raiz c√∫bica e x elevado a y).
-- √â importante observar que as S-expressions podem ser aninhadas, como pode ser visto no exemplo b e que n√£o h√° limites para o aninhamento de express√µes. Al√©m disso, √© importante lembrar que algumas opera√ß√µes solicitadas s√£o un√°rias e outras s√£o bin√°rias.

-- | tipo de dado que representa o argumento de uma express√£o, pode ser ou uma Express√£o, ou um Valor
data ExpressArg = Expression String | Value Float deriving (Show)

-- | Checa se dado argumento da express√£o √© igual a dada string
doExpressEqual :: ExpressArg -> String -> Bool
doExpressEqual (Expression express) str = express == str
doExpressEqual (Value val) str = isNumeric str && read str == val

-- | Gerencia qual a√ß√£o sera realizada no acumulator de acordo com o arg da express√£o
expressHandler :: ExpressArg -> [Float] -> [Float]
expressHandler (Expression express) acc = applier express acc
expressHandler (Value val) acc = acc ++ [val]

-- | Verifica se a String √© valida para ser um numero ou nao
isNumeric :: String -> Bool
isNumeric str = isJust(readMaybe str :: Maybe Float)

-- | Pega o penultimo elemento de uma lista
last2 :: [a] -> a
last2 list = head (tail (reverse list))

-- | Interpreta uma dada express√£o e retorna seu resultado como Float
interpret :: String -> Float
interpret "" = 0
interpret string = calculator(parseString (words string)) []

-- | Recebe uma lista de string, e devolve uma lista de argumentos da express√£o, que s√£o ou Values ou Expressions
parseString :: [String] -> [ExpressArg]
parseString [] = []
parseString list
  | isNumeric (head list) = Value (read (head list)) : parseString (tail list)
  | otherwise = Expression (head list) : parseString (tail list)

-- | Calcula dada express√£o representada pelo tipo criado e devolve um float
calculator :: [ExpressArg] -> [Float] -> Float
calculator [] acc = last acc
calculator list acc
  | doExpressEqual(head list) "(" || doExpressEqual(head list) ")" = calculator(tail list) acc
  | otherwise = calculator(tail list) (expressHandler (head list) acc)

-- | Aplica funcoes de acordo com o valor da express√£o recebida, levanta erro caso a express√£o seja invalida
applier :: String -> [Float] -> [Float]
applier express [] = error ("interpretError - No value given to apply on ["++express++"]") -- qtde de valores passados invalido
applier "sin" acc = acc ++ [sin (last acc)]                  -- seno
applier "cos" acc = acc ++ [cos (last acc)]           -- cosseno
applier "tan" acc = acc ++ [tan (last acc)]           -- tangente
applier "sqr" acc = acc ++ [last acc ** 2]            -- ao quadrado
applier "cbc" acc = acc ++ [last acc ** 3]            -- ao cubo
applier "sqrt" acc= acc ++ [last acc**(1/2)]         -- raiz quadrada
applier "cbct" acc= acc ++ [last acc**(1/3)]         -- raiz cubica
applier express [_] = error ("interpretError - Binary expression ["++express++"] got only one value to operate") -- qtde de valores passados invalido
applier "+" acc = acc ++ [(+) (last2 acc) (last acc)] -- soma
applier "-" acc = acc ++ [(-) (last2 acc) (last acc)] -- subtracao
applier "*" acc = acc ++ [(*) (last2 acc) (last acc)] -- multiplicacao
applier "/" acc = acc ++ [(/) (last2 acc) (last acc)] -- divisao
applier "exp" acc= acc ++ [last2 acc ** last acc]    -- elevado ao (potencia)
applier express _ = error ("interpretError - Invalid Expression ["++express++"]") -- express√£o invalida
