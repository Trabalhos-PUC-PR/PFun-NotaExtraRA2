module Ex1 where
import Text.Read
import Data.Maybe (isJust)
-- Exerc√≠cio 1:  CALCULADORA

-- Voc√™ dever√° implementar, em Haskell, uma calculadora capaz de realizar, em n√∫meros reais, as quatro opera√ß√µes, as opera√ß√µes trigonom√©tricas (seno, cosseno e tangente) e as opera√ß√µes de exponencia√ß√£o (quadrado, cubo, raiz quadrada, raiz c√∫bica e x elevado a y). Usando nota√ß√£o rpn de tal forma que todas as opera√ß√µes sejam representadas por uma S-expression. Como mostrado no exemplo
-- a seguir:

-- ùëé) ( 3.4 5.0 +)
-- ùëè) ( 3.4 (3.0 2 ùê∏ùëãùëÉ) +)

-- Caber√° a voc√™ definir como ir√° separar os operandos de cada opera√ß√£o. Tamb√©m caber√° a voc√™ determinar as palavras chaves que usar√° para representar as opera√ß√µes trigonom√©tricas (seno, cosseno e tangente) e as opera√ß√µes de exponencia√ß√£o (quadrado, cubo, raiz quadrada, raiz c√∫bica e x elevado a y).

-- √â importante observar que as S-expressions podem ser aninhadas, como pode ser visto no exemplo b e que n√£o h√° limites para o aninhamento de express√µes. Al√©m disso, √© importante lembrar que algumas opera√ß√µes solicitadas s√£o un√°rias e outras s√£o bin√°rias.

data ExpressArg = Expression String | Value Float deriving (Show)

-- Getters e "Checkers"
isExpress :: ExpressArg -> Bool
isExpress (Expression s) = True
isExpress (Value v) = False 
isValue :: ExpressArg -> Bool
isValue (Expression s) = False
isValue (Value v) = True 

getExp :: ExpressArg -> String
getExp (Expression s) = s
getExp (Value v) = ""
getVal :: ExpressArg -> Float
getVal (Expression s) = -0
getVal (Value v) = v 

-- | Verifica se a String √© valida para ser um numero ou nao
isNumeric :: String -> Bool
isNumeric str = isJust(readMaybe str :: Maybe Float)

-- | Pega o penultimo elemento de uma lista
last2 :: [a] -> a
last2 s = head (tail (reverse s))

-- | Interpreta uma dada express√£o e retorna seu resultado como Float
interpret :: String -> Float
interpret "" = 0
interpret s = calculator(parseString (words s)) []

-- | Recebe uma lista de strings, e da parse nela de jeito que os valores numericos 
-- s√£o um tipo, e express√µes s√£o outro, e uma lista com todos os valores "parseados"
parseString :: [String] -> [ExpressArg]
parseString s
  | length s > 1 && isNumeric (head s) = Value (read (head s)) : parseString (tail s)
  | length s > 1 && not(isNumeric (head s)) = Expression (head s) : parseString (tail s)
  | length s == 1 && isNumeric (head s) = [Value (read(head s))]
  | otherwise = [Expression (head s)]

-- | Calcula dada express√£o representada pelo tipo criado e devolve um float
calculator :: [ExpressArg] -> [Float] -> Float
calculator lista acc
  | null lista = last acc
  | getExp(head lista)=="(" || getExp(head lista)==")" = calculator(tail lista) acc
  | isValue (head lista) = calculator(tail lista) ( acc++[getVal(head lista)] )
  | isExpress (head lista) = calculator(tail lista) ( applier (getExp(head lista)) acc)
  | otherwise = error "interpretError - an argument inside the expression is invalid"

-- | Aplica funcoes de acordo com o valor da express√£o recebida, 
-- levanta erro caso a express√£o seja invalida
applier :: String -> [Float] -> [Float]
applier exp acc
  | exp == "sin" = init acc ++ [sin (last acc)]                  -- seno
  | exp == "cos" = init acc ++ [cos (last acc)]                  -- cosseno
  | exp == "tan" = init acc ++ [tan (last acc)]                  -- tangente
  | exp == "sqr" = init acc ++ [last acc ** 2]                   -- ao quadrado
  | exp == "cbc" = init acc ++ [last acc ** 3]                   -- ao cubo
  | exp == "sqrt" = init acc ++ [last acc**(1/2)]                -- raiz quadrada
  | exp == "cbct" = init acc ++ [last acc**(1/3)]                -- raiz cubica
  | exp == "+" = init (init acc) ++ [(+) (last2 acc) (last acc)] -- soma
  | exp == "-" = init (init acc) ++ [(-) (last2 acc) (last acc)] -- subtracao
  | exp == "*" = init (init acc) ++ [(*) (last2 acc) (last acc)] -- multiplicacao
  | exp == "/" = init (init acc) ++ [(/) (last2 acc) (last acc)] -- divisao
  | exp == "exp" = init (init acc) ++ [last2 acc ** last acc]    -- elevado ao (potencia)
  | otherwise = error ("interpretError - Invalid Expression ["++exp++"]") -- express√£o invalida

-- main :: IO ()
-- main = do
--   print (interpret "( 3 6 - )")
--   print (interpret "( 5 ( 3 1 - ) + )")
--   print (interpret "( ( 5 3 + ) cbc )")
--   print (interpret "( 3.4 ( 3.0 2 exp ) + )")
--   print (interpret "( 2 6 exp ) ( 3 9 * ) /")
--   print (interpret "( 69 2 exp ) ( 24 ( 3.14 -0.911 * ) + ) /")
--   print (interpret "( 3.1415926 2 / ) sin")
--   print (interpret " 4 sqrt")
--   print (interpret " 27 cbct")